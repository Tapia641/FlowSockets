\documentclass[12pt,twoside]{article}
\usepackage{amsmath, amssymb}
\usepackage{amsfonts}
\usepackage[active]{srcltx}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{makeidx}
\usepackage{amsthm}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}

\usepackage{verbatim}

%Para código en C ------------------------------------
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}

\lstset{ frame=Ltb,
framerule=0pt,
aboveskip=0.5cm,
framextopmargin=3pt,
framexbottommargin=3pt,
framexleftmargin=0.4cm,
framesep=0pt,
rulesep=.4pt,
backgroundcolor=\color{gray97},
rulesepcolor=\color{black},
%
stringstyle=\ttfamily,
showstringspaces = false,
basicstyle=\small\ttfamily,
commentstyle=\color{gray45},
keywordstyle=\bfseries,
%
numbers=left,
numbersep=15pt,
numberstyle=\tiny,
numberfirstline = false,
breaklines=true,
}

% minimizar fragmentado de listados
\lstnewenvironment{listing}[1][]
{\lstset{#1}\pagebreak[0]}{\pagebreak[0]}

\lstdefinestyle{consola}
{basicstyle=\scriptsize\bf\ttfamily,
backgroundcolor=\color{gray75},
}

\lstdefinestyle{C}
{language=C,
}
%------------------------------------------------------


\renewcommand{\baselinestretch}{1}
\setcounter{page}{1}
\setlength{\textheight}{21.6cm}
\setlength{\textwidth}{14cm}
\setlength{\oddsidemargin}{1cm}
\setlength{\evensidemargin}{1cm}
\pagestyle{myheadings}
\thispagestyle{empty}
\markboth{\small{Pr\'actica 1.1. Luis Enrique}}{\small{.}}
\date{}


%------------------------------------------------------
\begin{document}
\centerline{\bf Aplicaciones para comunicaciones de red, Sem: 2019-2, 3CM5, pr\'actica 1.1, Fecha: 02/02/2019}
\centerline{}
\centerline{}
\begin{center}
\Large{\textsc{Pr\'actica 1.1: SERVICIO DE TRANSFERENCIA DE ARCHIVOS}}
\end{center}
\centerline{}
\centerline{\bf {Hern\'andez Tapia Luis Enrique.}}
\centerline{}
\centerline{Escuela Superior de C\'omputo}
\centerline{Instituto Polit\'ecnico Nacional, M\'exico}
\centerline{$tapia641@gmail.com$}
\newtheorem{Theorem}{\quad Theorem}[section]
\newtheorem{Definition}[Theorem]{\quad Definition}
\newtheorem{Corollary}[Theorem]{\quad Corollary}
\newtheorem{Lemma}[Theorem]{\quad Lemma}
\newtheorem{Example}[Theorem]{\quad Example}
\bigskip

%------------------------------------------------------
\textbf{Resumen:} En esta pr\'actica se desarrolla una plicaci\'on para seleccionar m\'ultiples archivos y enviarlos a trav\'es del protocolo TCP \newline.
%------------------------------------------------------
\textbf{\newline Palabras clave:} TCP, IP, Sockets de flujo.
%------------------------------------------------------



%------------------------------------------------------
\section{Introducci\'on}

El env\'io de archivos a trav\'es de la red es una caracter\'istica importante para la gran mayor\'ia de las aplicaciones que hoy d\'ia se utilizan (blogs, redes sociales, mensajer\'ia instant\'anea, declaraci\'on de impuestos, educaci\'on en l\'inea, etc.), sin embargo, no todas las aplicaciones disponibles permiten el env\'io de archivos de gran tama\~no (p.e. El correo electr\'onico no permite enviar archivos de m\'as de 10 o 20 MB).
Esto hace necesario el desarrollo de aplicaciones que permitan transferir archivos sin importar el tamaño de \'estos.

\newpage
%------------------------------------------------------


\section{Conceptos B\'asicos}
A continuaci\'on se presentan algunas definiciones para que al lector le sea comprensible el tema en cuesti\'on.\newline
\newline
{\bf Notaci\'on $\Theta$:} 
En todo lo que sigue consideramos funciones definidas sobre $\mathbb{N}$
$\bigcup$  \{0\}. Sea g(n) una funci\'on. Se define $\theta$(g(n)) como: \newline $\theta$(g(n))= $\lbrace f(n)$ $\vert$ $\exists_{n}$ $C_{1}$, $C_{2}>0$ y $n_{o}=0$ tal que
$0\leq C_{1}g(n) \leq f(n )\leq C_{2}g(n)$ $\forall n\geq n_{o}$\} 
\newline \newline
{\bf Notaci\'on $O$:} Dada una funci\'on g(n). Se define $O$(g(n)) como: \newline $O$(g(n))= $\lbrace f(n)$ $\vert$ $\exists_{n}$ $C_{1}>0$ y $n_{o}>0$ tal que $0\leq f(n ) \leq C_{1}g(n)$ $\forall n\geq n_{o}$\} 
\newline \newline
{\bf Notaci\'on $\Omega$:} Dada una funci\'on g(n). Se define $\Omega$(g(n)) como: \newline $\Omega$(g(n))= $\lbrace f(n)$ $\vert$ $\exists_{n}$ $C_{1}>0$ y $n_{o}>0$ tal que $0\leq C_{1}g(n)\leq f(n ) $ $\forall n\geq n_{o}$\}
\newline \newline 


%------------------------------------------------------

\textbf{\newline C\'odigo de Huffman:}
\newline
El algoritmo de Huffman es usado en la compresi\'on de datos. Puesto es capaz de representar un conjunto de s\'imbolos obtenidos a partir de cierto alfabeto, usando el menor n\'umero de bits posible, pero preservando en todo momento la capacidad de descomprimir o decodificar la informaci\'on \newline \newline
El algoritmo se propuso en 1952 como una forma sencilla y \'optima de mapear cada s\'imbolo de un alfabeto con un c\'odigo de longitud \'optima. El proceso de asignaci\'on de c\'odigos se lleva a cabo mediante la construcci\'on de un \'arbol binario, desde las hojas hacia la ra\'iz, de manera que los nodos hojas son los s\'imbolos del alfabeto. A continuaci\'on un ejemplo gr\'afico.

Precedemos a comprimir la siguiente cadena de car\'acteres.
\begin{center}
\begin{tabular}[t]{|l |c |r |r |r |r |}
\hline
L & a & p & t & o & p\\
\hline
\end{tabular}
\end{center}
\newpage
Enseguida se crea su tabla de frecuencias.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|l|}
\hline
Cr\'acter & Frecuencia \\
\hline \hline
L &  1 \\ \hline
a &  1 \\ \hline
p &  2 \\ \hline
t &  1 \\ \hline
o &  1 \\ \hline
\end{tabular}
\caption{Tabla de frecuencia}
\label{tabla:Tabla1}
\end{center}
\end{table}

Ordenamos de forma ascendente con \textit{QuickSort}

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|l|}
\hline
Cr\'acter & Frecuencia \\
\hline \hline
L &  1 \\ \hline
a &  1 \\ \hline
t &  1 \\ \hline
o &  1 \\ \hline
p &  2 \\ \hline
\end{tabular}
\caption{Tabla de frecuencia ordenada}
\label{tabla:Tabla1}
\end{center}
\end{table}

Insertamos en una lista enlazada de \'arboles los car\'acteres con su n\'umero de frecuencia.
%\begin{figure}[h]
%	\centering
%\includegraphics[width=1\textwidth]{img/1.png}
%	\caption{Paso 1 del la codifiaci\'on de Huffman.}
%\end{figure}
Tomamos los dos primeros nodos y creamos un \'arbol con ellos donde la ra\'iz ser\'a la suma de la frecuencia de ambos. El nodo de la izquierda ser\'a el primero que tomamos y el de la derecha el segundo.\newline

El resultado es: \textbf{11011110000110\\}


%------------------------------------------------------


\newpage
\textbf{\newline QuickSort:\newline }

Fue desarrollado por C.A.R. Hoare en 1960. El algoritmo original es recursivo, pero se utilizan versiones iterativas para mejorar su rendimiento (los algoritmos recursivos son en general más lentos que los iterativos, y consumen más recursos). El algoritmo fundamental es el siguiente:

\begin{itemize}
    \item Eliges un elemento de la lista. Puede ser cualquiera. Lo llamaremos elemento de divisi\'on.
    \item Buscas la posici\'on que le corresponde en la lista ordenada.
    \item Acomodas los elementos de la lista a cada lado del elemento de divisi\'on, de manera que a un lado queden todos los menores que \'el y al otro los mayores.
    \item En este momento el elemento de divisi\'on separa la lista en dos sublistas.
    \item Realizas esto de para cada sublista mientras éstas tengan un largo mayor que 1.
\end{itemize}

%------------------------------------------------------


\newpage
\textbf{\newline Estrategia Greedy:\newline } 

A continuaci\'on se presenta la estrategia utilizada en la codificaci\'on de Huffman denominada como el m\'etodo voraz o \textit{Greedy Method}. El prop\'osito de un algoritmo voraz es encontrar una soluci\'on, es decir, una asociaci\'on de valores a todas las variables tal que el valor de la funci\'on objetivo sea \'optimo. Para ello sigue un proceso secuencial en el que cada paso toma una decisi\'on . \newline \newline La decisi\'on es localmente \'optima, es decir, ning\'un otro valor de los disponibles para esa variable lograr\'ia  que la funci\'on objetivo tuviera un mejor valor. \newline \newline El siguiente paso del algoritmo voraz es encontrar un problema id\'entido, pero estrictamente menor, al que ten\'ia en el paso anterior y vuelve a plicar la misma funci\'on de selecci\'on para tomar la siguiente decisi\'on. Un criterio importante es nuncaintentar asignar un nuevo valor a la misma variabl, es decir, no regresarse.

Pseudoc\'odigo:

%------------------------------------------------------
\newpage
\section{Experimentaci\'on y Resultados}

En la pr\'actica se implement\'o el algoritmo de codificaci\'on de Huffman, sujeto a los siguientes criterios.\newline \textbf{\newline 1.} Implementar el algoritmo de la codificaci\'on de Huffman con las siguientes condiciones:\newline \newline
\textbf{Para la Codificaci\'on.}\newline
Entrada: Un archivo de texto con extensi\'on .txt (original.txt) a codificar.\newline
Salida: se generaran tres archivos .txt.\newline
\textbf{Frecuencias.txt: }Mostrar\'a la tabla de frecuencias de los caracteres que
aparecen en el archivo original.txt. \newline


%---------------------------------------------------------------------------------
		
\section{Conclusiones}

\textbf{\newline Luis Enrique:}
La compresi\'on de archivos la hemos venido manejando sin tener noci\'on de alg\'un algoritmo que permita \'esto. Con la codificaci\'on de Huffman tenemos una estrategia Greedy para realizarlo, debido a que llega a una soluci\'on local, obteniendo la tabla de frecuencias y para obser el resultado de la compresi\'on pasamos la cadena binaria a su equivalente en \textit{ascii}, tambi\'en se implementa arboles binarios, tema visto en estructuras de datos.\newline \newline
\textbf{\newline Miguel \'Angel:}
Cuando necesitamos comprimir informaci\'on el algoritmo de Huffman es \'util pues al generar c\'odigos binarios para cada car\'acter que se repite, no es necesario utilizar todo el c\'odigo ASCII, lo que representa un ahorro significativo en espacio si sólo se utiliza cierto rango de caracteres. Este tipo de compresi\'on de informaci\'on no genera p\'erdida de informaci\'on por lo cual se puede utilizar para cualquier tipo de informaci\'on. 

  \newpage

\section{Bibliograf\'ia}
\begin{thebibliography}{X}
	
	\bibitem{Baz} \textsc{ T. H}, Cormen et al, \textit{Introduction to Algorithms}. Ed third. Cambridge: The MIT Press, 2009.
	
	\bibitem{bib1} \textsc{J. I}\textit{ An\'alisis y dise\~no de algoritmos:} un enfoque te\'orico y pr\'actico
	
	
\bibitem{a}  \textit{A method for the construction of minimum-redundancy codes, Proceedings of the I.R.E., sept 1952, pp 1098\-1102}

\bibitem{g} \textit{https://ronnyml.wordpress.com/2009/07/19/quicksort-en-c/}
\end{thebibliography}
\end{document}